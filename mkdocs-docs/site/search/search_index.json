{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"NQSync Documentation","text":"<p>Welcome to the home page of official documentation of NQSync. NQSync is a web-based network simulator, that allows user to build network topologies, assign QKD protocols like DPS QKD and CoW protocol, and analyse their performance. This documentation will help you get started from launching the simulator and creating network topologies on the interactive canvas, to configuring QKD protocols and evaluating the results.</p>"},{"location":"#content-overview","title":"Content Overview","text":"<p>Use the sidebar on the left to explore the following sections:</p> <ul> <li> <p>Introduction: Overview of NQSync, a visual QKD network simulator supporting DPS and CoW protocols for secure quantum communication.</p> </li> <li> <p>Installation Guide: Set up the project on your local machine.</p> </li> <li>Getting Started: Learn how to run your first simulation.</li> <li>Understanding Results: Dive deep into key performance indicators.</li> <li>Developer Guide: Explore the project layout and architecture.</li> <li>Future Works: Check upcoming features and contribute to NQSync.</li> </ul>"},{"location":"Contents/Developer-guide/","title":"Developer Guide","text":""},{"location":"Contents/Developer-guide/#project-layout","title":"Project Layout","text":"<p>This section describes the overall directory layout and key files of the NQSync QKD Simulation App project.</p> <pre><code>app.py                     # Main Flask application file.\nrequiremnets.txt           # Python dependencies\nvenv/                      # Virtual environment for the project (optional).\n\nstatic/                    # Frontend static assets.\n    images/                # All images used in HTML and documentation.\n    style.css              # Custom CSS for coming soon page.\n    styles.css             # Custom CSS for the Home page of NQSync.\n    styless.css            # Custom CSS for the canvas.\n\n\ntemplates/                 # HTML templates rendered by Flask.\n    main_index.html        # Landing/home page of the app.\n    canvas.html            # Interactive simulator canvas interface.\n    dps_form.html          # Configuration form for DPS QKD protocol.\n    cow_form.html          # Configuration form for CoW QKD protocol.\n    results.html           # Displays simulation results\n    coming_soon.html       # Placeholder for upcoming SDK simulation feature.\n\n\nmkdocs-docs/               # Documentation folder.\n    mkdocs.yml             # MkDocs configuration file.\n    docs/                  # All markdown pages and related assets.\n        index.md           # Documentation homepage.\n        Contents/          # Contains Other markdown pages like Introduction.md, Installation Guide.md etc.\n        styles/            # Contains extra.css for styling\n        assets/            # Contains the images used in the documentation\n\n    venv/                  # Virtual environment for documentation (optional).\n</code></pre> <p></p>"},{"location":"Contents/Developer-guide/#system-architecture","title":"System Architecture","text":"<p>This section explains the architectural components behind the NQSync QKD Simulation Platform.</p>"},{"location":"Contents/Developer-guide/#backend","title":"Backend","text":"<p>The backend is implemented using Python (Flask), providing the core logic for QKD protocol simulations.</p> <p>Key Features:</p> <ul> <li>RESTful API using <code>GET</code> and <code>POST</code> requests</li> <li>Theory-compliant simulation models for:   \u00a0\u00a0\u00a0\u00a0- DPS-QKD (Differential Phase Shift)   \u00a0\u00a0\u00a0\u00a0- CoW-QKD (Coherent One-Way)</li> </ul> <p>Main Functions:</p> <pre><code>def simulate_cow_qkd(distance_km, fiber_type='underground', mu=0.1, pulse_rate=1e9,\n                     det_eff=0.2, dark_rate=100, dead_time=20e-6,\n                     error_correction_efficiency=0.9, visibility=0.98, num_pulses=100000):\n    ...\n\ndef simulate_dps_qkd(distance_km, fiber_type='underground', mu=0.2, pulse_rate=1e9,\n                     det_eff=0.06, dark_rate=800, dead_time=20e-6,\n                     disclosure_rate=0.03125, compression_ratio=0.5,\n                     visibility=0.98, num_pulses=10000000):\n    ...\n</code></pre>"},{"location":"Contents/Developer-guide/#api-methods","title":"API Methods","text":"<p>The Flask backend exposes the following HTTP methods for client interaction:</p> <ul> <li>GET \u2013 Used for rendering pages and serving static files.</li> <li>POST \u2013 Used to handle form submissions and trigger QKD simulations based on user input.</li> </ul>"},{"location":"Contents/Developer-guide/#web-frontend","title":"Web Frontend","text":"<p>The frontend is built using HTML + CSS+ JavaScript and provides an interactive and visual user interface.</p> <ul> <li> <p>Network Topology Builder   Drag-and-drop interface for visually creating QKD network topologies.</p> </li> <li> <p>Protocol Configuration Modals   Interactive forms for assigning protocol and hardware parameters to each link.</p> </li> <li> <p>Results   Displays simulation metrics (e.g., QBER, key rate) .</p> </li> </ul> <p>These files define the structure and flow of the user interface in the NQSync web app:</p> <pre><code>main_index.html     #  Landing/home page of the application.\ncanvas.html         #  Interactive simulator canvas for building networks.\ndps_form.html       #  Configuration form for the DPS QKD protocol.\ncow_form.html       #  Configuration form for the CoW QKD protocol.\nresults.html        #  Displays simulation results.\ncoming_soon.html    #  Placeholder for the upcoming SDK simulation module.\n</code></pre>"},{"location":"Contents/Future-Works/","title":"Future Works","text":"<p>As the QKD Simulation Platform continues to evolve, the following enhancements are planned for future releases:</p> <ul> <li> <p>SDK Version:   We aim to develop a Software Development Kit (SDK) version of the application, allowing developers and researchers to easily integrate QKD simulation capabilities into their own tools and pipelines.</p> </li> <li> <p>Support for Additional Protocols:   Expanding beyond DPS and CoW, we plan to include more QKD protocols such as BB84, enabling broader experimentation and analysis across use cases.</p> </li> </ul>"},{"location":"Contents/Future-Works/#thank-you","title":"Thank You","text":"<p>Thankyou so much for exploring, testing, and supporting NQSync.</p>"},{"location":"Contents/Future-Works/#contribute","title":"Contribute","text":"<p>We welcome contributions from the community! If you would like to improve the platform, suggest new features, or report bugs, please visit our GitHub Repository and feel free to open an issue or submit a pull request.</p>"},{"location":"Contents/Getting-Started/","title":"Getting started","text":"<p>Now that the installation is complete, you are ready to run your first simulation! This section will guide you through building your network on the canvas, assigning QKD protocols, configuring links, and running simulations effortlessly.</p>"},{"location":"Contents/Getting-Started/#working-with-the-canvas","title":"Working with the Canvas","text":""},{"location":"Contents/Getting-Started/#using-the-canvas-and-toolbar","title":"Using the Canvas and Toolbar","text":"<p>1. Launch the Simulator  Click the \u201cLaunch Simulator\u201d button from the main menu or landing page. This opens the interactive canvas interface.</p> <p> </p> <p>2. Explore the Toolbar  Once the canvas loads, you will see several key tools on the top toolbar:</p> <p> </p> <p>\u00a0\u00a0\u00a0\u00a0- Add Nodes: Create devices (systems or ports) on the canvas. These nodes can be connected with links and configured with QKD protocols. \u00a0\u00a0\u00a0\u00a0- Simulate Network: Run the simulation once you have designed and congigured your network topology. Results such as QBER and key rate will be displayed. \u00a0\u00a0\u00a0\u00a0- Reset: Clear the canvas to start designing a new network from scratch.</p>"},{"location":"Contents/Getting-Started/#configure-nodes-and-create-links","title":"Configure Nodes and Create Links","text":"<p>Double-click a node to open its configuration panel and establish connections:</p> <ul> <li>Node Name: Custom name for the selected device.</li> <li>From: Automatically filled with the selected source node.</li> <li>To: Select the destination node to form a link.</li> <li>Protocol: Choose a QKD protocol \u2014 DPS QKD or CoW QKD.</li> <li>Cancel: Close the panel without saving changes.</li> <li>Delete Node: Remove the node (only if no links are connected).</li> <li>Configure: Submit parameters and create the link.</li> </ul>"},{"location":"Contents/Getting-Started/#configure-protocol-parameters","title":"Configure Protocol Parameters","text":"<p>When you click Configure, you will be directed to one of the following forms depending on the selected protocol \u2014 either DPS QKD or CoW QKD. These forms are pre-filled with default values, which you can modify as needed.</p> <p>Once you click Save Configuration, you will return to the canvas where a colored link will appear between your selected systems:</p> <ul> <li>Blue for DPS QKD</li> <li>Yellow CoW QKD</li> </ul> <p>You can then click Simulate Network to view performance metrics and results.</p> <p>To delete a link, left + right click simultaneously on it and confirm when prompted.</p> <p> </p>"},{"location":"Contents/Getting-Started/#running-simulation","title":"Running Simulation","text":"<p>After configuring all desired links:</p> <ol> <li>Click Simulate Network.</li> <li>The system will run backend simulations based on your parameters.</li> <li>A results page will display key metrics like:    \u00a0\u00a0\u00a0\u00a0 - Quantum Bit Error Rate (QBER)    \u00a0\u00a0\u00a0\u00a0 - Final key rate</li> </ol>"},{"location":"Contents/Getting-Started/#available-protocol-parameters","title":"Available Protocol Parameters","text":""},{"location":"Contents/Getting-Started/#common-parameters-for-both-dps-cow","title":"Common Parameters (for both DPS &amp; CoW)","text":"Parameter Description <code>distance_km</code> Distance between two nodes (in kilometers) over which quantum key distribution is performed. <code>fiber_type</code> Type of optical fiber used in the channel. Can be \"underground\" or \"aerial\", affecting signal loss. <code>mu</code> Mean photons per pulse . Represents the average number of photons sent by Alice per pulse.(0.2 for DPS, 0.1 for CoW by default). <code>pulse_rate</code> Pulse repetition rate (in Hz) at which photons are sent by Alice. <code>det_eff</code> Detector efficiency. Probability (between 0 and 1) that a photon is successfully detected. <code>dark_rate</code> Dark count rate of the detector (counts per second). Represents false clicks due to noise or thermal effects. <code>dead_time</code> Dead time of the detector (in seconds). It is the interval after each detection during which the detector is inactive and cannot record further events. <code>visibility</code> Interference visibility, indicating the quality of phase coherence. Values closer to 1 imply ideal interference and lower error rates. <code>num_pulses</code> Number of photon pulses sent by Alice during the simulation. Affects how statistically stable the results are."},{"location":"Contents/Getting-Started/#dps-qkd-specific-parameters","title":"DPS QKD-Specific Parameters","text":"Parameter Description <code>disclosure_rate</code> The fraction of the raw key disclosed for QBER estimation. Higher values improve accuracy but reduce usable key length. <code>compression_ratio</code> The factor with which the key is shortened during privacy amplification to remove leaked information."},{"location":"Contents/Getting-Started/#cow-qkd-specific-parameters","title":"CoW QKD-Specific Parameters","text":"Parameter Description <code>error_correction_efficiency</code> Efficiency of the error correction algorithm used in post-processing. Typically between 0.9 and 1. Higher values preserve more of the key. <p>You are now ready to simulate a quantum network! Continue to explore different protocols and settings to understand how quantum communication behaves under varied conditions.</p>"},{"location":"Contents/Installation-Guide/","title":"Installation Guide","text":"<p>This guide provides step-by-step instructions for installing and setting up the NQSync QKD Simulation Platform on your system.</p>"},{"location":"Contents/Installation-Guide/#system-requirements","title":"System Requirements","text":""},{"location":"Contents/Installation-Guide/#minimum-requirements","title":"Minimum Requirements","text":"<ul> <li>Operating System: Windows 10+, macOS 10.14+, or Linux (Ubuntu 18.04+)</li> <li>Python: 3.9 or higher supported by Flask</li> </ul>"},{"location":"Contents/Installation-Guide/#recommended-requirements","title":"Recommended Requirements","text":"<ul> <li>Operating System: Windows 11, macOS 12+, or Ubuntu 20.04+</li> <li>Python: 3.10 or higher</li> </ul>"},{"location":"Contents/Installation-Guide/#prerequisites","title":"Prerequisites","text":""},{"location":"Contents/Installation-Guide/#python-installation","title":"Python Installation","text":"<ol> <li>Download Python: https://www.python.org</li> <li>Install Python: Run the installer and check \u201cAdd Python to PATH\u201d</li> <li>Verify Installation: Run this in your terminal/command prompt :    <pre><code>python --version\npip --version\n</code></pre></li> </ol>"},{"location":"Contents/Installation-Guide/#git-installation","title":"Git Installation","text":"<ol> <li>Download Git: https://git-scm.com</li> <li>Install Git: Use default settings during installation</li> <li>Verify Installation: Run this in your terminal/command prompt :    <pre><code>git --version\n</code></pre></li> </ol>"},{"location":"Contents/Installation-Guide/#installation-methods","title":"Installation Methods","text":""},{"location":"Contents/Installation-Guide/#method-1-clone-from-repository-recommended","title":"Method 1: Clone from Repository (Recommended)","text":"<p>1. Clone the Repository:</p> <pre><code>git clone https://github.com/BhumikaUpadhyay05/NQSync.git\ncd NQSync\n</code></pre> <p>2. (Optional) Create and Activate Virtual Environment:</p> <pre><code>python -m venv venv\n# Windows\nvenv\\Scripts\\activate\n# macOS/Linux\nsource venv/bin/activate\n</code></pre> <p>3. Install Python Dependencies:</p> <pre><code>pip install -r requirements.txt\n</code></pre> <p>4. Launch the Application:</p> <pre><code>python app.py\n</code></pre> <p>You will be directed to the NQSync homepage in your default browser.</p>"},{"location":"Contents/Installation-Guide/#method-2-download-zip-archive","title":"Method 2: Download ZIP Archive","text":"<ol> <li>Download ZIP: Navigate to the GitHub repository, click \"Code\" \u2192 \"Download ZIP\".</li> <li>Extract: Unzip to your desired location.</li> <li>Follow steps 2-4 from Method 1.</li> </ol>"},{"location":"Contents/Installation-Guide/#platform-specific-instructions","title":"Platform-Specific Instructions","text":""},{"location":"Contents/Installation-Guide/#windows","title":"Windows","text":"<pre><code># Open Command Prompt or PowerShell as Administrator\n# Then follow Method 1\n</code></pre>"},{"location":"Contents/Installation-Guide/#macos","title":"macOS","text":"<pre><code># Install Homebrew (if not already installed)\n/bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"\n\nbrew install python\nbrew install git\n\n# Then follow Method 1\n</code></pre>"},{"location":"Contents/Installation-Guide/#linux-ubuntudebian","title":"Linux (Ubuntu/Debian)","text":"<pre><code>sudo apt update &amp;&amp; sudo apt upgrade\nsudo apt install python3 python3-pip python3-venv\ncurl -fsSL https://deb.nodesource.com/setup_lts.x | sudo -E bash -\nsudo apt install git\n\n# Then follow Method 1\n</code></pre> <p>You are now ready to simulate a quantum network! Quick Start Guide \u2013 Learn how to run your first simulation</p>"},{"location":"Contents/Introduction/","title":"Introduction","text":""},{"location":"Contents/Introduction/#what-is-nqsync","title":"What is NQSync?","text":"<p>NQSync is a web-based network simulator made for analysing quantum networks. Inspired by tools like ns-3, it enables users to build and simulate network topologies through an intuitive canvas interface.</p> <p>Made for a researcher, student, or developer, NQSync offers a platform to design and analyze networks enhanced with Quantum Key Distribution (QKD) protocols such as DPS and CoW\u2014giving insights into performance variations based on distance, link type, and protocol parameters.</p> <p>Built for education and research, NQSync mimics real-world network behavior in software, enabling experimentation with QKD protocols such as DPS and CoW</p>"},{"location":"Contents/Introduction/#key-features","title":"Key Features","text":"<ul> <li> <p>Visual Topology Builder   It helps user Create and configure networks by dragging multiple nodes and connecting them with links in a canvas.</p> </li> <li> <p>QKD protocols   Simulate QKD protocols such as DPS (Differential Phase Shift) and CoW (Coherent One-Way) for secure key exchange.</p> </li> <li> <p>Result Metrics   Run simulations and analyse performance metrics like QBER, final key rate, and signal transmittance for multiple nodes.</p> </li> <li> <p>Customizable Parameters   Adjust physical and protocol-level parameters (fiber length, efficiency, dark counts, etc.) for each link.</p> </li> <li> <p>Educational &amp; Research Focused   Ideal for experimenting with network topologies, or exploring hybrid communication systems.</p> </li> </ul>"},{"location":"Contents/Introduction/#what-is-quantum-key-distribution","title":"What is Quantum Key Distribution?","text":"<p>Quantum Key Distribution (QKD) is a secure communication method that uses quantum mechanics to enable two parties to generate a shared, secret random key known only to them. This key can then be used to encrypt and decrypt messages. The fundamental advantage of QKD is its ability to detect any attempt at eavesdropping. Quantum Key Distribution (QKD) leverages the fundamental principles of quantum mechanics to enable cryptographic systems with unconditional security, guaranteed by the laws of physics.</p>"},{"location":"Contents/Introduction/#what-is-coherent-one-way-cow-protocol","title":"What is Coherent One-Way (CoW) Protocol?","text":"<ul> <li>The CoW QKD protocol was introduced to enhance robustness against photon-number splitting attacks.</li> <li>Alice uses a laser source to send a sequence of time-separated optical pulses through an optical fiber.</li> <li>Logical bits are encoded as:   \u00a0\u00a0\u00a0\u00a0 - Bit '0': signal pulse followed by an empty time slot.   \u00a0\u00a0\u00a0\u00a0 - Bit '1': empty time slot followed by a signal pulse.</li> <li>Occasionally, Alice sends decoy sequences with two consecutive pulses to detect eavesdropping.</li> <li>Bob receives the pulses and uses a beam splitter to split incoming signals into two paths.</li> <li>One path is sent directly to a detector for time-of-arrival analysis, which reveals the key bit.</li> <li>The other path enters an interferometer to check for coherence between adjacent pulses.</li> <li>If coherence is maintained, it indicates the transmission is secure and eavesdropping is unlikely.</li> <li>By analyzing both arrival time and interference visibility, Bob can detect disturbances caused by potential attackers.</li> </ul>"},{"location":"Contents/Introduction/#what-is-differential-phase-shift-dps-qkd-protocol","title":"What is Differential Phase Shift (DPS) QKD Protocol?","text":"<ul> <li>The DPS QKD protocol was proposed in 2002 by Inoue et al.</li> <li>Alice creates a weak coherent pulse (WCP) \u2014 dim laser pulses each carrying very few photons (on average 0.2).</li> <li>She randomly changes the phase of each pulse to either 0 or \u03c0 using a phase modulator.</li> <li>She sends these modulated pulses to Bob using an optical fiber.</li> <li>Bob passes the received pulses to a 1-bit delay Mach\u2013Zehnder interferometer.</li> <li>This device compares the phase of two back-to-back pulses by making them interfere with each other.</li> <li>The outputs of the Mach\u2013Zehnder interferometer are measured either by single photon detectors (SPDs) or superconducting nanowire single photon detectors (SNSPDs).</li> <li>Depending on which detector clicks, Bob can figure out the phase difference between the two pulses \u2014 this carries the key information.</li> <li>Bob tells Alice the exact times when one of his detectors clicked (but not which detector).</li> <li>Alice checks the two pulses she sent at those times:</li> <li>If the phase difference was 0, they both write down bit 0.</li> <li>If the phase difference was \u03c0, they both write down bit 1.</li> </ul>"},{"location":"Contents/Introduction/#result","title":"Result","text":"<p>They now share a secret key known only to them, which can be used to encrypt messages securely.</p>"},{"location":"Contents/Introduction/#post-processing-of-raw-keys","title":"Post-Processing of Raw Keys","text":"<p>After generating the raw key using CoW or DPS QKD, post-processing is essential to correct errors and ensure security. This process involves three main steps:</p>"},{"location":"Contents/Introduction/#1-parameter-estimation","title":"1. Parameter Estimation","text":"<ul> <li>A small portion of the raw key is publicly disclosed to estimate the Quantum Bit Error Rate (QBER).</li> <li>The fraction of the raw key used for this estimation is called the disclose rate (DR).</li> <li>Parameter estimation helps detect the presence of an eavesdropper (Eve) and assess transmission errors.</li> <li>Ideally, DR is 50%, but this significantly reduces the final key rate. In practice, a DR of 3\u201310% is often sufficient.</li> </ul>"},{"location":"Contents/Introduction/#2-error-correction","title":"2. Error Correction","text":"<ul> <li>Based on the measured QBER, the sender and receiver apply error-correction protocols (e.g., LDPC codes) to remove discrepancies and align their keys.</li> </ul>"},{"location":"Contents/Introduction/#3-privacy-amplification","title":"3. Privacy Amplification","text":"<ul> <li>To eliminate any partial information Eve might have obtained, the key is shortened.</li> <li>The shortening factor is called the compression ratio (CR).</li> <li>This step ensures strong secrecy by producing the final secure key.</li> </ul>"},{"location":"Contents/Undertanding-results/","title":"Understanding results","text":""},{"location":"Contents/Undertanding-results/#distance-loss","title":"Distance &amp; Loss","text":"<ul> <li> <p><code>Distance_km</code> \u2013 Distance in kilometers between the sender (Alice) and receiver (Bob) in the fiber-optic network.</p> </li> <li> <p><code>Fiber_Type</code> \u2013 Type of optical fiber used for transmission:   \u00a0\u00a0\u00a0\u00a0\u2022 <code>Underground</code> \u2013 Fiber lines laid below the surface, typically experience a loss of 0.2 dB/km. These are more stable and less affected by environmental conditions.   \u00a0\u00a0\u00a0\u00a0\u2022 <code>Aerial</code> \u2013 Fiber lines suspended above ground (e.g., on poles), experience slightly higher attenuation at around 0.3 dB/km, due to exposure to weather and physical disturbances.</p> </li> <li> <p><code>Channel_Loss_dB</code> \u2013 Total optical power loss calculated as <code>\u03b1 \u00d7 distance</code>, where <code>\u03b1</code> is the attenuation coefficient based on fiber type.</p> </li> <li> <p><code>Transmittance</code> \u2013 The ratio of power successfully transmitted through the fiber, computed as <code>T = 10^(-loss_dB / 10)</code>.</p> </li> </ul>"},{"location":"Contents/Undertanding-results/#signal-detection","title":"Signal &amp; Detection","text":"<ul> <li> <p><code>Signal_Probability_per_Pulse</code> \u2013 Probability that a signal photon sent by Alice is successfully detected by Bob is: <code>\u03bc \u00d7 T \u00d7 \u03b7</code>, where: <code>\u03bc</code> = mean photon number <code>T</code> = transmittance <code>\u03b7</code> = detector efficiency</p> </li> <li> <p><code>Detection_Probability</code> \u2013 Total probability that a pulse results in detection (including both signal and noise) is: <code>P_signal + (dark_rate / pulse_rate)</code></p> </li> </ul>"},{"location":"Contents/Undertanding-results/#key-rate-calculations","title":"Key Rate Calculations","text":"<ul> <li><code>QBER</code> \u2013Quantum Bit Error Rate, the fraction of incorrect bits shared between Alice and Bob, given by: <code>bit_errors / comparable_bits</code>.</li> <li><code>Bit_Errors</code> \u2013 Number of mismatched bits between Alice and Bob during key comparison.</li> <li><code>Key_Match_Ratio</code> \u2013 <code>1 - QBER</code>, percentage of matching bits.</li> <li><code>Raw_Key_Rate_bps</code> \u2013 Initial bit rate of key generation based on detection probability, given by: <code>R_raw = (pulse_rate \u00d7 P_detect) / (1 + pulse_rate \u00d7 P_detect \u00d7 dead_time)</code>.</li> <li><code>Sifted_Key_Rate_bps</code> \u2013 Rate of key bits retained after sifting.(~50% of raw key is usable.) given by: <code>R_sifted = 0.5 \u00d7 R_raw</code></li> <li><code>Final_Key_Rate_bps</code> \u2013 Final usable key rate after error correction:</li> </ul> <p>\u00a0\u00a0\u00a0\u00a0\u2022 <code>DPS QKD</code> \u2013 <code>R_final = R_sifted \u00d7 (1 - disclosure_rate) \u00d7 (1 - compression_ratio)</code></p> <p>\u00a0\u00a0\u00a0\u00a0\u2022 <code>CoW QKD</code> \u2013 <code>R_final = R_sifted \u00d7 (1 - error_correction_efficiency \u00d7 QBER)</code></p>"},{"location":"Contents/Undertanding-results/#bit-detection-statistics","title":"Bit &amp; Detection Statistics","text":"<ul> <li><code>Raw_Key_Length_Alice</code> \u2013 Total number of bits Alice attempted to encode and transmit.</li> <li><code>Raw_Key_Length_Bob</code> \u2013 Total number of bits detected and stored by Bob.</li> <li><code>Num_Detections</code> \u2013 Total detections, including both signal-based and dark counts.</li> <li><code>Signal_based_Detections</code> \u2013 Count of detections caused by actual signal photons.</li> <li><code>Dark_only_Detections</code> \u2013 Detections that occurred due to detector noise or false positives (not actual signal).</li> <li><code>Comparable_Bits</code> \u2013 Bits that are eligible for comparison between Alice and Bob to compute QBER.</li> <li><code>Visibility</code> \u2013 Depicts interference quality. Affects how accurately Bob can infer Alice\u2019s bit from phase differences.</li> </ul>"}]}